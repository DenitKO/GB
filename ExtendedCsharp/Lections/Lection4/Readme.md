# Разработка приложения на С# (лекции)

## Содержание 

## Урок 4. Коллекции (часть 2)

[Dictionary<TKey,TValue>](#dictionarytkeytvalue)

[Особенности работы с Dictionary](#особенности-работы-с-dictionary)

- [Основные методы Dictionary<TKey, TValue>:](#основные-методы-dictionarytkey-tvalue)

[HashSet<T>](#hashset)

[Особенности работы с HashSet](#особенности-работы-с-hashset)

[Другие коллекции из System.Collections.Generic](#другие-коллекции-из-systemcollectionsgeneric)

[LINQ](#linq)

[Особенности работы с LINQ](#linq)

### Dictionary<TKey,TValue>

Dictionary удобен тем, что доступ к любому элементу с большой вероятностью можно получить за константную скорость O(1) и в более редких случаях O(N).

- GetHashCode() - метод позволяет получить хеш-код объекта – специальное значение, результат работы однонаправленной функции. Типом этого значения является int. Алгоритм генерации хеш-кода может отличаться в разных версиях .Net. Платформа старается обеспечить равномерное распределение хеш-кодов в диапазоне int, но не гарантирует уникальность значений. Возможна ситуация, когда два объекта имеют одинаковый хеш-код: значение int находится в диапазоне от -2,147,483,648 до 2,147,483,647, и этого диапазона может не хватить в условиях, когда количество объектов превышает это значение.

```C#
var o1 = new object();
int hashcode = o1.GetHashCode();
int hashcodeHashCode = hashcode.GetHashCode();
object o2 = hashcodeHashCode;

Console.Write($"Object o1 hashcode = {hashcode}, o2 hashcode = {o2}, o1==o2 = {o1.Equals(o2)}");

// Object o1 hashcode = 54267293, o2 hashcode = 54267293, o1==o2 = False
```

Код показывает генерацию двух объектов с одинаковым хеш-кодом. Мы создали экземпляр класса object o1. Получили хеш-код созданного объекта и сохранили его в переменную hashcode. Далее получили хеш-код переменной hashcode и записали его в переменную hashcodeHashcode, которую обернули в object o2. Сравнение хеш-кодов o1 и o2 показывает, что они идентичны. Однако, метод Equals позволяет различить эти два объекта, возвращая false при сравнении. 

Метод GetHashCode можно переопределить в классах, унаследованных от object.

- Equals(object) - позволяет сравнить текущий экземпляр объекта с экземпляром, переданным в метод. Если они идентичны, метод вернет true, иначе false. Для reference-типов Equals будет сравнивать, являются ли объекты одним экземпляром, путем сравнения ссылок на эти объекты (метод ReferenceEquals); для value-типов метод будет сравнивать значения.

```C#
struct SomeStruct
{
    public int Field;
}
static void Main(string[] args)
{
    var a = new object();
    var b = new object();
    var c = a;
    Console.WriteLine(a.Equals(b)); // False
    Console.WriteLine(a.Equals(c)); // True

    var sa = new SomeStruct();
    var sb = new SomeStruct();

    sa.Field = 10;


    Console.WriteLine(sa.Equals(sb)); // Fasle

    sb.Field = 10;

    Console.WriteLine(sa.Equals(sb)); // True
}
```
Код показывает особенности работы Equals для reference и value-типов. a и b два независимых объекта, тогда как с ссылается на a. Как видно из результатов запуска программы, a!=b, но a==c. Обратную ситуацию мы наблюдаем с экземплярами структуры sa и sb – до тех пор, пока поля структуры не равны sa!=sb. Как только мы устанавливаем sa.Field = sb.Field = 10, метод Equals начинает возвращать true при сравнении sa и sb.

Метод Equals можно переопределить, если вам требуется реализовать свои уникальные критерии сравнения.

Теперь когда мы разобрались как работают эти два метода, настало время объяснить как устроен Dictionary. Словарь содержит массив типа int называемый “корзины” или buckets, а также массив entries - Entry[] предназначенный для хранения

```C#
private uint hashCode;

public int next;

public TKey key;

public TValue value;
```

Каждый раз когда мы добавляем пару Ключ-Значение (TKey-TValue) в словарь происходит следующее: определяется номер позиции в массиве buckets по следующей формуле:

```C#
int bucketNum = (value.GetHashCode() & 0x7fffffff) % buckets.Length;
```
логическое умножение на 0x7fffffff требуется чтобы инвертировать значение хеш кода в случае если оно отрицательно

%bucket.Length требуется для распределения хеш кодов по диапазону корзин от 0 до buckets.Length

Затем создается новая структура Entry и ее свойства Key и Value устанавливаются равными TKey, TValue. Структура затем добавляется в массив entries (в следующую свободную позицию), а ссылка на ее индекс присваивается buckets[bucketNum].

```C#
entries[nextEntry] = new Entry(TKey,TValue);
buckets[bucketNum] = nextEntry;
nextEntry++;
```
Когда мы получаем элемент из словаря, происходит следующее, мы получаем номер корзины по формуле:
```C#
int bucketNum = (value.GetHashCode() & 0x7fffffff) % buckets.Length;
```

далее получаем номер корзины

```C#
int entryNum = buckets[bucketNum];
```

И получаем элемент из корзины.

```C#
return entries[entryNum];
```

Как видите операция выполняется за константное время. Но как быть в ситуациях когда у двух объектов один хеш-код и

```C#
int bucketNum = (value.GetHashCode() & 0x7fffffff) % buckets.Length;
```

укажет на одну и ту же позицию в массиве buckets. Такая ситуация называется коллизией и разрешается следующим образом. Поняв что buckets[bucketNum], уже ссылается на какой-то элемент, словарь поступит следующим образом: он создаст новый Entry

```C#
entries[nextEntry] = new Entry(TKey,TValue);
```

а потом присвоит его индекс но не в массив buckets[bucketNum] (там уже лежит индекс предыдущего Entry) а в

```C#
entries[buckets[bucketNum]].Next = nextEntry;
```
То есть entry может ссылаться на следующее entry с ключом TKey имеющим аналогичный индекс в массиве buckets. 

Теперь давайте разберем то как происходит извлечение элемента из словаря в случае если имеет место коллизия. 

Первый шаг универсален - мы получаем номер корзины по формуле

```C#
int bucketNum = (value.GetHashCode() & 0x7fffffff
%buckets.Length;
```

после этого мы переходим в entries[bucketNum]

```C#
var entry = entries[buckets[bucketNum]];
```
и проверяем его значение Next Если Next не равняется -1 (означает что следующей элемента нет) значит нам нужно выбрать TValue перебрав текущий и возможно следующие Entry. В процессе перебора мы определяем искомый TValue сравнивая TKey каждого Entry(с помощью метода Equals) с тем что передан в индексатор. В коде это можно упрощенно выразить следующим образом.:

```C#
var entry = entries[buckets[bucketNum]];
while(entry.Next>=0)
{
if(entry.TKey.Equals(TKey))
    return entry.TValue;
else
    entry = entries[entry.Next];
}
```

Как уже упоминалось сложность поиска в этом случае O(N) Словарь поддерживает следующие интерфейсы: IDictionary<TKey, TValue>, ICollection<KeyValuePair<TKey, TValue>>, IEnumerable<KeyValuePair<TKey, TValue>>, IEnumerable, IDictionary, ICollection, IReadOnlyDictionary<TKey, TValue>, IReadOnlyCollection<KeyValuePair<TKey,TValue>>,ISerializable,IDeserializationCallback where TKey : notnull

Класс Dictionary имеет множество конструкторов, опишем лишь некоторые из них:
- Dictionary() - конструктор по умолчанию
- Dictionary(IEnumerable<TKey, TValue>) - создает словарь из элементов
полученных из энумератора объекта, класс которого поддерживает
соответствующий интерфейс
- Dictionary(IDictionary<TKey, TValue>) - создает словарь на основе объекта
класс которого поддерживает интерфейс IDictionary<TKey, TValue>
- Dictionary(IEqualityComparer<TKey>) - создает словарь компаратором предопределяющим поведение при сравнении элементов (требуется в случаях коллизии) 

Помимо этого класс Dictionary имеет конструкторы позволяющие определять размер внутреннего хранилища выделенного под хранение элементов в сочетании с уже описанными выше параметрами, а также конструкторы с информацией о сериализации и десериализции объекта. Свойства Dictionary<TKey,TValue>:
- Comparer - возвращает IEqualityComparer. Если IEqualityComparer не был явно задан в конструкторе от в этом качестве выступает EualityComarer<TKey>.Default который реализует сравнение путем вызова метода Equals.
- Count - получает количество элементов Dictionary
- Item[TKey] - получает/записывает элемент из словаря с помощью переданного в индексатор ключа
- Keys - коллекция ключей
- Values - коллекция значений

```C#
static void Main(string[] args)
{
    var capitals = new Dictionary<string, string>();

    capitals["Россия"] = "Москва";
    capitals["Бразилия"] = "Бразилиа";
    capitals["Австралия"] = "Камберра";
    capitals["Германия"] = "Берлин";

    Console.WriteLine("Столицы:");
    foreach (string capital in capitals.Values)
    {
        Console.Write(capital + ", ");
    }

    Console.WriteLine();
    Console.WriteLine("Страны:");
    foreach (string country in capitals.Keys)
    {
        Console.Write(country + ", ");
    }

    Console.WriteLine();
    Console.WriteLine("Столицы стран:");
    foreach (KeyValuePair<string, string> capital in capitals)
    {
        Console.WriteLine($"Столица страны {capital.Key} = {capital.Value}.");
    }
}
```

dictionary[TKey] = value; - создаст значение если его нет

value = dictionary[TKey]; - вызовет ошибку если значения TKey нет в словаре

[🔝 Наверх](#содержание)

#### Основные методы Dictionary<TKey, TValue>:

- Add(TKey, TValue) - добавляет значение TValue для ключа TKey в словарь. Если значение уже есть в словаре, операция приведет к ошибке времени выполнения.

```C#
var capitals = new Dictionary<string, string>();


capitals.Add("Россия", "Москва");
capitals.Add("Бразилия", "Бразилиа");
capitals.Add("Австралия", "Камберра");
capitals.Add("Германия", "Берлин");

Console.WriteLine("Столицы стран:");
foreach (KeyValuePair<string, string> capital in capitals)
{
    Console.WriteLine($"Столица страны {capital.Key} = {capital.Value}.");
}
```
- Clear() - очищает словарь, удаляя из него все ключи и значения

```C#
var capitals = new Dictionary<string, string>();


capitals.Add("Россия", "Москва");
capitals.Add("Бразилия", "Бразилиа");
capitals.Add("Австралия", "Камберра");
capitals.Add("Германия", "Берлин");

capitals.Clear();

Console.WriteLine("Столицы стран:"); // Столицы стран:
foreach (KeyValuePair<string, string> capital in capitals)
{
    Console.WriteLine($"Столица страны {capital.Key} = {capital.Value}."); //
}
```

- Contains(TKey) - метод возвращает true если указанный ключ имеется в словаре
- Contains(TValue) - метод возвращает true если указанное значение имеется в словаре

```C#
var capitals = new Dictionary<string, string>();


capitals.Add("Россия", "Москва");
capitals.Add("Бразилия", "Бразилиа");
capitals.Add("Австралия", "Камберра");
capitals.Add("Германия", "Берлин");

capitals.Clear();

Console.WriteLine($"В словаре есть ключ Россия? - " + capitals.ContainsKey("Россия")); // True
Console.WriteLine($"В словаре есть ключ Франция? - " + capitals.ContainsKey("Франция")); // False
Console.WriteLine($"В словаре есть значение Москва? - " + capitals.ContainsKey("Москва")); // True
Console.WriteLine($"В словаре есть ключ Париж? - " + capitals.ContainsKey("Париж")); // False
```

- EnsureCapacity(int) - увеличивает(если требуется) размер внутреннего хранилищи словаря до указанного в параметре размера
- Equals(object) - возвращает true если переданный в метод объект равняется объекту переданному в метод. Критерии равенства можно задавать самостоятельно переопределяя этот метод в своих классах. В коллекции Stack, метод Equals возвращает true в случае если сравниваемый объект является тем же что объект метод которого мы вызываем.
- GetEnumerator() - возвращает энумератор, с помощью него мы выводим элементы стека в цикле foreach. При этом свойство Current энумератора равняется паре ключ-значение.
- GetHashCode() - возвращает хеш-код объекта
- Remove(TKey) - удаляет элемент с указанным ключом из словаря.Метод возвращает true в случае успеха и false если элемент не найден

```C#
var capitals = new Dictionary<string, string>();

capitals.Add("Россия", "Москва");
capitals.Add("Бразилия", "Бразилиа");
capitals.Add("Австралия", "Камберра");
capitals.Add("Германия", "Берлин");

capitals.Remove("Австралия");

Console.WriteLine("Столицы стран:"); // Столицы стран:
foreach (KeyValuePair<string, string> capital in capitals)
{
    Console.WriteLine($"Столица страны {capital.Key} = {capital.Value}."); //
}
```
- Remove(TKey, out TValue) - удаляет элемент с указанным ключом из словаря, при этом копирую значение TValue в out параметр. true/false возвращается в зависимости от результата удаления (как и в прошлом методе)

```C#
var capitals = new Dictionary<string, string>();

capitals.Add("Россия", "Москва");
capitals.Add("Бразилия", "Бразилиа");
capitals.Add("Австралия", "Камберра");
capitals.Add("Германия", "Берлин");

if (capitals.Remove("Австралия", out string removed))
{
    Console.WriteLine("Удалённая столица-" + removed); // Удалённая столица-Камберра
}

if (capitals.Remove("Кения", out string removed2)) //
{
    Console.WriteLine("Удалённая столица-" + removed2);
}

Console.WriteLine("Столицы стран:");
foreach (KeyValuePair<string, string> capital in capitals)
{
    Console.WriteLine($"Столица страны {capital.Key} = {capital.Value}.");
}
```

- TrimExcess() - урезает размер памяти используемой для хранения элементов до актуального размера (равного уже имеющемуся количеству элементов)
- TrimExcess(int) - урезает размер памяти используемой для хранения элементов до указанного размера
- TryAdd(TKey,TValue) - метод аналогичен методы Add за исключением ошибки при попытки добавления уже имеющегося элемента. Метод TryAdd возвращает false если добавление не удалось завершить из-за наличия в словаре элемента с TKey, тогда как метод Add в такой ситуации приведет к возникновению ошибки времени выполнения

```C#
var capitals = new Dictionary<string, string>();

capitals.Add("Россия", "Москва");
capitals.Add("Бразилия", "Бразилиа");
capitals.Add("Австралия", "Камберра");
capitals.Add("Германия", "Берлин");

if (capitals.TryAdd("Австралия", "Вашингтон") == false)
{
    Console.WriteLine("Элемент уже есть в словаре"); // Элемент уже есть в словаре
}
else
    Console.WriteLine("Элемент добавлен");

if (capitals.TryAdd("Австрия", "Вена") == false)
{
    Console.WriteLine("Элемент уже есть в словаре");
}
else
    Console.WriteLine("Элемент добавлен"); // Элемент добавлен

Console.WriteLine("Столицы стран:");
foreach (KeyValuePair<string, string> capital in capitals)
{
    Console.WriteLine($"Столица страны {capital.Key} = {capital.Value}.");
}
```

-  TryGetValue(TKey, out TValue) - метод пытается получить значение из словаря в out параметр TValue. В случае успеха возвращает true.

```C#
var capitals = new Dictionary<string, string>();

capitals.Add("Россия", "Москва");
capitals.Add("Бразилия", "Бразилиа");
capitals.Add("Австралия", "Камберра");
capitals.Add("Германия", "Берлин");

if (capitals.TryGetValue("Австралия", out string value))
{
    Console.WriteLine(value); // Камберра
}
else
    Console.WriteLine("Элемент не найден");

if (capitals.TryGetValue("Австрия", out value))
{
    Console.WriteLine(value);
}
else
    Console.WriteLine("Элемент не найден"); // Элемент не найден
```

[🔝 Наверх](#содержание)

### Особенности работы с Dictionary

Словарь применяется везде где нужен быстрый доступ к элементам по ключу. Другое название словаря - хеш-таблица или hashtable. Если доступ по ключу не нужен

```C#
static void Main(string[] args)
{
    var s = "Текст с повторяющимися повторяющимися повторяющимися словами. Выведи количество повторов вместе со словами";

    StringBuilder sb = new StringBuilder();
    Dictionary<string, int> count = new Dictionary<string, int>();

    foreach (var myChar in s)
    {
        if (" ,.-".Contains(myChar))
        {
            if (sb.Length > 0)
            {
                if (count.ContainsKey(sb.ToString()))
                {
                    count[sb.ToString()]++;
                }
                else
                    count[sb.ToString()] = 1;
                sb.Clear();
            }
        }
        else
            sb.Append(myChar);
    }
    /*
     * вторая проверка после окончания цикла нужна
     * так как в конце предложения может не оказаться проблема
     * или знака препинания и условие в цикле не сработает
     */
    if (count.ContainsKey(sb.ToString()))
    {
        count[sb.ToString()]++;
    }
    else
        count[sb.ToString()] = 1;

    foreach (var pair in count)
    {
        Console.WriteLine($"Слово '{pair.Key}' повторяется {pair.Value} раз");
    }
}
```
Аналогичный код, сделанный с помощью списка занял бы значительно больше времени так как нам пришлось бы каждый раз искать ключ за O(N) времени (помните поиск в списке). Здесь же поиск происходит за O(1) и программа работает ровно столько времени сколько требуется для того чтобы перебрать нашу строку и собрать из нее отдельные слова.

Не всегда Dictionary является идеальным примером. Если мы знаем весь диапазон значений которыми мы оперируем то бывают случаи когда значительно проще использовать простой массив для операции подсчета

Давайте покажем это на примере подсчета количества повторов символов в строке с английским текстом. Условимся что буквы могут быть только английские и заглавные буквы равняются строчным.

```C#
var s = "To use or not to use Dictionary";

Dictionary<char, int> count = new Dictionary<char, int>();

foreach (var myChar in s)
{
    if (!Char.IsAsciiLetter(myChar))
        continue;
    var lowerChar = Char.ToLower(myChar);
    if(count.ContainsKey(lowerChar))
        count[lowerChar]++;
    else 
        count[lowerChar] = 1;
}

foreach (var pair in count)
{
    Console.WriteLine($"{pair.Key} = {pair.Value}");
}
```

Мы перебираем наш текст и если символ не является буквой мы пропускаем виток итерации, в противном случае мы приводим символ к нижнему регистру и записываем его в словарь. По завершению цикла мы выводим на экран наш словарь с частотой каждого из символов.

Задача казалось бы решена, но как уже было сказано раньше, если можно обойтись более простой структурой данных то лучше так и сделать: мы знаем что в английском алфавите 26 буквы и каждой из буквы можно назначить номер от 0 до 25 в том порядке в котором они следуют в алфавите. Тогда мы могли бы вести подсчет букв в массиве из 26 элементов. Давайте попробуем такой вариант

```C#
var s = "To use or not to use Dictionary";

            int[] count = new int[26];

            foreach (var myChar in s)
            {
                if (!Char.IsAsciiLetter(myChar))
                    continue;

                var lowerChar = Char.ToLower(myChar);

                int pos = ((byte)lowerChar) - ((byte)'a');

                count[pos]++;
            }

            for (int i = 0; i < 26; i++)
            {
                if (count[i] > 0)
                    Console.WriteLine($"{(char)(i+(byte)'a')}={count[i]}");
            }
```

Обратите внимание. Результат подсчета равен тому что мы получили в предыдущем примере, но теперь бонусом мы получили отсортированный по алфавиту результат. 

Поясним как работает алгоритм - в ASCII а именно им кодируется английский алфавит, каждому символу соответствует определенный номер от 0 до 127. Все буквы идут последовательно. В C# мы можем привести char к byte получа его порядковый номер в кодировке ASCII(int pos = ...). Буквы алфавита начинаются не с нуля и символ ‘a’ имеет порядковый номер 97. Наш массив для подсчета имеет размерность 26 поэтому чтобы рассчитать позицию конкретной буквы нам нужно отнять от нее порядковый номер ‘a’ что мы и делаем в (16) строке. Получив номер ячейки в массиве мы просто увеличиваем значение в этой конкретной ячейке на 1. Массив инициализируется значениями по умолчанию (для int это 0) поэтому в самом начале подсчета количество каждой из букв равно 0. В последнем цикле мы перебираем наш массив обрабатывая значения в тех ячейках где оно не равно нулю преобразовывая номер ячейки в букву алфавита с помощью операции явного приведения.

Всегда старайтесь выбирать как можно более простую структуру данных если это возможно, так как они зачастую дают константную скорость выполнения требуемой операции и занимают меньше объема в памяти.

[🔝 Наверх](#содержание)

### HashSet<T>

Коллекция HashSet или множество представляет из себя хранилище элементов работающее по аналогии с Dictionary но в отличие от словаря hashset хранит только значения. Коллекция позволяет быстро добавить, удалить или определить имеется ли в коллекции заданный элемент. Стоимость операции O(1) но в редких случаях коллизий O(N)

HashSet поддерживает следующие интерфейсы: ICollection<T>, IEnumerable<T>, IEnumerable, ISet<T>, IReadOnlyCollection<T>, IReadOnlySet<T>, ISerializable, IDeserializationCallback

Класс HashSet имеет множество конструкторов, опишем лишь некоторые из них:

- HashSet() - конструктор по умолчанию
- HashSet(IEnumerable<T>) - создает множество из элементов полученных из энумератора объекта, класс которого поддерживает соответствующий интерфейс
- HashSet(ISet<T) - создает множество на основе объекта класс которого поддерживает интерфейс ISet<T>
- HashSet(IEqualityComparer<T>) - создает множество с компаратором предопределяющим поведение при сравнении элементов (требуется в случаях коллизии)

Свойства HashSet<T>:
- Comparer - возвращает IEqualityComparer. Если IEqualityComparer не был явно задан в конструкторе от в этом качестве выступает EqualityComarer<T>.Default который реализует сравнение путем вызова метода Equals.
- Count - хранит количество элементов множества

#### Основные методы HashSet<T>:

- Add(T) - добавляет элемент в множество. Если элемент добавлен в множество то метод возвращает true, если же элемент уже присутствует в множестве - метод возвращает false

- Clear() - очищает множество, удаляя все его элементы

- Contains(T) - проверяет наличие элемента в множестве

- CopyTo(T[]) - копирует элементы множества в массив T[]
- CopyTo(T[], int start) - копирует элементы множества в массив T[] располагая их с позиции start
- CopyTo(T[], int start, int count) - копирует элементы в количестве count множества в массив T[] располагая их с позиции start

- EnsureCapacity(int) - метод работает также как и для словаря или например списка - он убеждается что размер внутреннего хранилища достаточен чтобы вместить количество элементов, переданное в метод. Вы наверняка заметили что мы повторяем описание этого метода от коллекции к коллекции - все потому что в нагруженных приложениях такая казалось бы мелочь как заблаговременное выделение достаточного количества памяти играет важную роль которой не стоит пренебрегать.
- ExceptWith(IEnumerable<T>) - удаляет из множества элементы которые есть в переданном в метод IEnumerable<T>.

```C#
var set1 = new HashSet<int>(new int[]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 0});
var set2 = new HashSet<int>(new int[]{ 5, 6, 7, 8, 9, 0});

set1.ExceptWith(set2);

foreach (var s in set1)
    Console.Write(s+" "); // 1 2 3 4
```
Вызов метода удаляет из множества set1 все элементы хранящиеся в set2

- GetEnumerator() - возвращает энумератор (помните интерфейс IEnumerable?)
- GetHashcode() - возвращает хеш-код объекта.
- IntersectWith(IEnumerable<T>) - (пересечение)модифицирует множество таким образом что в нем остаются только те элементы которые являются общими с IEnumerable переданный в метод

```C#
var set1 = new HashSet<int>(new int[]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 0});
var set2 = new HashSet<int>(new int[]{ -1, 5, 6, 7, 8, 9, 0, 10});

set1.IntersectWith(set2);

foreach (var s in set1)
    Console.Write(s+" "); // 5 6 7 8 9 0
```

IsProperSubsetOf(IEnumerator<T>) - (подмножество)определяет является ли множество подмножеством представленным интерфейсом IEnumerable при условии что они различаются по количеству элементов (не равны)

```C#
var set1 = new HashSet<int>(new int[]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 0});
var set2 = new HashSet<int>(new int[]{ 5, 6, 7, 8, 9, 0 });
var set3 = new HashSet<int>(new int[]{ 5, 6, 7, 8, 9, 0 });

System.Console.WriteLine(set2.IsProperSubsetOf(set1)); // True
System.Console.WriteLine(set2.IsProperSubsetOf(set3)); // False
```
Множестве set2 является подмножеством set1 так как все элементы входящие в set2 имеются в set1, но множество set2 не является подмножеством set3 так как они не отличаются по длине , хоть их элементы и совпадают.

IsProperSupersetOf(IEnumerable<T>) - (надмножество)определяет является ли множество переданной в метод (представленное IEnumerable) подмножеством множества при условии что они различаются по количеству элементов 

```C#
var set1 = new HashSet<int>(new int[]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 0});
var set2 = new HashSet<int>(new int[]{ 5, 6, 7, 8, 9, 0 });
var set3 = new HashSet<int>(new int[]{ 5, 6, 7, 8, 9, 0 });
var set4 = new HashSet<int>(new int[]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 0});

System.Console.WriteLine(set1.IsProperSupersetOf(set2)); // True
System.Console.WriteLine(set3.IsProperSupersetOf(set4)); // False
```

Множестве set2 является подмножеством set1 так как все элементы входящие в set2 имеются в set1, но множество set4 не является подмножеством set1 так как они не отличаются по длине , хоть их элементы и совпадают.

- IsSubsetOf(IEnumerable<T>) -(подмножество) определяет является ли множество подмножеством представленным интерфейсом IEnumerable. Метод не учитывает длину сравниваемых множеств в случае если они совпадают (в отличие от IsProperSubsetOf)

```C#
var set1 = new HashSet<int>(new int[]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 0});
var set2 = new HashSet<int>(new int[]{ 5, 6, 7, 8, 9, 0 });
var set3 = new HashSet<int>(new int[]{ 5, 6, 7, 8, 9, 0 });
var set4 = new HashSet<int>(new int[]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 0});

System.Console.WriteLine(set2.IsSubsetOf(set1)); // True
System.Console.WriteLine(set3.IsSubsetOf(set4)); // True
```

- IsSupersetOf(IEnumerable<T>) - (надмножество)определяет является ли множество переданной в метод (представленное IEnumerable) подмножеством множества без оглядки на длину как в методе IsProperSupersetOf

```C#
var set1 = new HashSet<int>(new int[]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 0});
var set2 = new HashSet<int>(new int[]{ 5, 6, 7, 8, 9, 0 });
var set3 = new HashSet<int>(new int[]{ 5, 6, 7, 8, 9, 0 });
var set4 = new HashSet<int>(new int[]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 0});

System.Console.WriteLine(set1.IsSupersetOf(set2)); // True
System.Console.WriteLine(set1.IsSupersetOf(set4)); // True
```

Overlaps(IEnumerable<T>) - (перекрытие)метод возвращает true если множество имеет общие элементы с IEnumerable<T> переданным в метод.

```C#
var set1 = new HashSet<int>(new int[]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 });
var set2 = new HashSet<int>(new int[]{ 20, 30, 40, 1, 3, 4 });
var set3 = new HashSet<int>(new int[]{ 20, 30, 40 });

System.Console.WriteLine(set1.Overlaps(set2)); // True
System.Console.WriteLine(set1.Overlaps(set3)); // False
```

Remove(T) - удаляет элемент из множества возвращая true в случае успеха. Если же элемент отсутствует, метод возвращает false
```C#
var set1 = new HashSet<int>(new int[]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 });
var set2 = new HashSet<int>(new int[]{ 20, 30, 40, 1, 3, 4 });
var set3 = new HashSet<int>(new int[]{ 20, 30, 40 });

System.Console.WriteLine(set1.Remove(1)); // True
System.Console.WriteLine(set1.Remove(1)); // False
```

RemoveWhere(Predicate<T>) - удаляет из множества элементы совпадающие с предикатом. Метод возвращает количество удаленных элементов.

```C#
static bool IsEven(int i)
{
    return i % 2 == 0;
}

var set1 = new HashSet<int>(new int[]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 });
var set2 = new HashSet<int>(new int[]{ 20, 30, 40, 1, 3, 4 });
var set3 = new HashSet<int>(new int[]{ 20, 30, 40 });

System.Console.WriteLine(set1.RemoveWhere(IsEven)); // 5

foreach (var i in set1)
{
    System.Console.Write(i + " "); // 1 3 5 7 9
}
```

С помощью уже известного нам предиката мы удаляем из множества set1 все четные элементы. в количестве 5 штук

 - SetEquals(IEnumerable<T>) -(тождество) метод возвращает true если множество равно набору представленному IEnumerable иными словами если количество элементов в обоих коллекциях одинаково и сами элементы равны.

- SymmetricExceptWith(IEnumerable<T>) - модифицирует текущее множество таким образом чтобы в нем были только элементы содержащиеся либо в одном либо в другом множестве но не в обоих
```C#
var set1 = new HashSet<int>(new int[]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 });
var set2 = new HashSet<int>(new int[]{ 1, 2, 3, 10, 11, 12, 13, 14, 15 });

set1.SymmetricExceptWith(set2);

foreach (var i in set1)
{
    System.Console.Write(i + " "); // 12 11 10 4 5 6 7 8 9 0 13 14 15
}
```
**Обратите внимание, тут это хорошо видно, множество не гарантирует сохранение порядка следования элементов.**

- TrimExcess() - обрезает размер внутреннего хранилища до размеров множества.
- UnionWith(IEnumerable<T>) - (объединение)модифицирует очередь добавляя в нее все элементы коллекции представленной IEnumerable (разумеется если они еще не находятся в множестве)

[🔝 Наверх](#содержание)

### Особенности работы с HashSet

Множества хорошо применять в алгоритмах где необходимо быстро проверить нахождение элемента в наборе. Множества применяются например в базах данных. Если вы обрабатываете набор одинаковых элементов при этом работа с каждым из элементов занимает значительное время и не должна повторяться, имеет смысл сохранять обработанные элементы в множестве для того чтобы исключить обработку повторов, при этом сам процесс проверки на уникальность будет работать за O(1).

На собеседованиях часто дают следующую задачу: дан массив целых чисел и искомое число, найдите в массиве два числе сумма которых является искомому. Давайте попробуем решить эту задач. Пусть наш массив будет:

-2,10,2,31,4,5,16,7,8,9 и искомое число 29. Решением задачи будут числа -2 и 31.

Самое простое решение которое приходита на ум - это реализовать вложенный цикл перебирающий все числа и складывающий каждое из них со всем элементами этого же массива во вложенном цикле.

```C#
int[] arr = new int[] { -2, 10, 2, 31, 4, 5, 16, 7, 8, 9 };
int target = 29;

for (int i = 0; i < arr.Length; i++)
{
    for (int j = 0; j < arr.Length; j++)
    {
        if (i == j)
            continue;
        if (arr[i] + arr[j] == target)
        {
            Console.WriteLine($"Числа = {arr[i]},{arr[j]}"); // Числа = -2,31
            return;
        }
    }
}
Console.WriteLine("Числа не найдены");
```

Во внутреннем цикле(строки 11-21) мы перебираем все элементы массива (кроме совпадающего с текущим элементом внешнего цикла) и складываем их с текущим элементов внешнего цикла(15 строка). Когда сумма равняется искомому числы мы пишем ответ(17 строка). Легко подсчитать что если длина массива = N то мы выполняем N*N операций или же N^2. Сложность нашего решения O(N^2) те квадратичная.

Теперь давайте решим задачу при помощи HashSet.

```C#
int[] arr = new int[] { -2, 10, 2, 31, 4, 5, 16, 7, 8, 9 };
int target = 29;

HashSet<int> set = new HashSet<int>();

foreach (var i in arr)
{
    if (set.Contains(target - i))
    {
        System.Console.WriteLine($"Числа = {target - i},{i}"); // Числа = -2,31
        return;
    }
    else
    {
        set.Add(i);
    }
}
Console.WriteLine("Числа не найдены");
```

В цикле мы перебираем наш массив. Для каждого очередного числа мы определяем его вторую половинку(target-i) которая может образовать в сумме искомое число. После чего ищем половинку в множестве за O(1). Если поиск (строка 14) успешен значит мы нашли решение и тогда искомые числа это текущее (i) и target-i. В противном случае мы добавляем текущее число в множество. Обратите внимание на то что мы перебираем наш массив единожды и зная что операция проверки вхождения значения в множество занимает константное время, мы можем заключить что сложность нашего алгоритма O(N).

Однако увеличив производительность нашего алгоритма мы также увеличили количество памяти потребляемой им. Можно сказать что мы используем дополнительные N памяти для решения задачи.



[🔝 Наверх](#содержание)

### Другие коллекции из System.Collections.Generic

- PriorityQueue<TElement,TPriority> - коллекция реализует приоритетную очередь позволяющую считывать элементы в порядке заданного приоритета. При этом очередность элементов с одинаковым приоритетом не гарантируется. Основой этой коллекции является структура данных heap или куча (https://ru.wikipedia.org/heap).

```C#
var pq = new PriorityQueue<string, int>();

pq.Enqueue("Элемент 1", 3);
pq.Enqueue("Элемент 2", 3);
pq.Enqueue("Элемент 3", 3);
pq.Enqueue("Элемент 4", 2);
pq.Enqueue("Элемент 5", 2);
pq.Enqueue("Элемент 6", 2);
pq.Enqueue("Элемент 7", 1);
pq.Enqueue("Элемент 8", 1);

while (pq.Count > 0) { 
    Console.WriteLine(pq.Dequeue()); }
/*
Элемент 7
Элемент 8
Элемент 6
Элемент 4
Элемент 5
Элемент 1
Элемент 3
Элемент 2
*/
```
SortedSet<T>,SortedDictionary<T>- коллекции реализуют множество и словарь с отсортированным порядком элементов. Основой этих коллекций является структура данных red-black tree или красно-черное дерево (https://ru.wikipedia.org/red-black-tree).

```C#
var dic = new SortedDictionary<string, int>();

dic.Add("10", 10);
dic.Add("1", 1);
dic.Add("5", 5);
dic.Add("-1", -1);

foreach (var pair in dic)
{
    Console.Write($"{pair.Key}:{pair.Value} "); // -1:-1 1:1 10:10 5:5
}

Console.WriteLine();

var set = new SortedSet<int>();
set.Add(10);
set.Add(1);
set.Add(-1);
set.Add(25);

foreach (var e in set)
{
    Console.Write($"{e} "); // -1 1 10 25
}
```

Код показывает работу SortedSet и SortedDictionary. Обратите внимание что по причине необходимости поддержания элементов в отсортированном порядке, сложность вставки элементов в коллекцию равна O(log N) что выше чем сложность вставки в HashSet.

- ReadOnlyCollection<T>, ReadOnlyDictionary<TKey, TValue> - коллекции позволяют работать с данными в режиме только для чтения без возможности модифицировать элементы образующие их.

```C#
int[] ints = { 0, 1, 2, 3 };

var readOnly = ints.ToList().AsReadOnly();

// readOnly[0] = 1; - Куда полез! Написано же, "Только для Чтения"! Атата!
```
Пример получения ReadOnlyCollection из массива int. Поскольку массив не поддерживает метод позволяющий получить экземпляр только-для чтения, сначала мы преобразуем его в обычный List<int> а потом уже получаем экземпляр ReadOnlyCollection

[🔝 Наверх](#содержание)

### LINQ

LINQ расшифровывается как Language-Integrated Query или по-русски встроенный язык запросов. Это мощный инструмент позволяющий обращаться SQL-подобным синтаксисом или же с помощью цепочки методов к источникам данных таким как IEnumerable, IEnumerable<T>, XML-сущностям, веб-сервисам и базам данных. Результатом выполнения LINQ являются объект с поддержкой IEnumerable или же IQueryable - один интерфейс нам уже знаком, второй же мы разберем подробнее в лекции про работу баз данных

Чтобы проиллюстрировать возможности LINQ давайте решим несколько простых задач.

Представьте что у нас есть массив string[] хранящий имена людей. Нам нужно выбрать те имена который которые начинают на определенные буквы. Как уже сказано ранее, LINQ имеет два синтаксиса один - SQL-подобный, второй же работает как вызов цепочки методов и пример ниже показывает оба этих способа.

```C#
string[] names = { "Анна", "Алена", "Анастасия", "Александр", "Алексей", "Елена", "Федор", "Михаил", "Елисей"};

IEnumerable<string> namesA = from name in names
                             where name.StartsWith('А')
                             select name;

foreach (var n in namesA)
{
    Console.Write($"{n},"); // Анна,Алена,Анастасия,Александр,Алексей,
}

Console.WriteLine();

IEnumerable<string> namesE = names.Where(n => n.StartsWith('Е'));

foreach (var n in namesE)
{
    Console.Write($"{n},"); // Елена,Елисей,
}
```
На скриншоте, массив определяем на строке 8. Массив names типа string представляет из себя набор имен. Попробуем получить из него имена начинающиеся на букву ‘А’ а потом имена на букву ‘E’ . Строки 10-13 показывают применение LINQ с SQL-подобным синтаксисом. Давайте разберем подробнее что происходит в запросе:
1. Мы обращаемся к массиву строк и потому результатом выполнения LINQ выражения будет IEnumerable <string> и следовательно мы объявляем переменную этого типа: IEnumerable<string> namesA которой присваиваем LINQ-выражение (оно идет после знака =)
2. Ключевое слово from задает источник данных для нашего запроса(names). При этом мы объявляем переменную(name) значение которой равняется одной записи источника данных. Эта переменная нам нужна для работы последующих блоков запроса
3. Ключевое слово where позволяет задать условие выборки. Выражение следующие после where должно давать результат true или false на выходе при это будут выбраны только те элементы которые попали в условие при котором выражении в where равняется true. Мы используем этот блок чтобы отфильтровать имена начинающиеся на букву “А”. Как вы помните у объектов типа string есть метод StartsWith позволяющий определить начинается ли строка с заданной подстроки или символа. Именно этим методом мы воспользовались для фильтрации всех элементов начинающихся на заданную букву. В качестве экземпляра строки для которого мы вызываем этот метод, мы используем уже знакомую нам переменную name заданную в предыдущем блоке.
4. Блоке select определяет в каком виде отфильтрованные элементы попадут в энумератор на выходе. В нашем случае мы отдаем элемент как он есть и потому пишем просто name

Еще раз - запрос строит энумератор из набора элементов name полученных из массива names (блок select), беря только те элементы для которых заданное условие справедливо(блок where). Элементы прошедшие фильтрацию отдаются в энумератор без изменений(блок select). В 14-17 строках мы используя наш энумератор выводим результат операции на экран. Теперь такого же результата добьемся с помощью вызова цепочки LINQ-методов. Посмотрите на строку 21. На этот раз мы получаем имена начинающиеся на букву ‘E’. Давайте разберем что в ней происходит:
1. Как и в прошлый раз мы определяем переменную типа IEnumerable<string> в которую присваиваем результат выражения идущего после знака =
2. Методы LINQ работают как методы расширений (см прошлые лекции) для интерфейс IEnumerable, при этом большая часть методов также возвращает IEnumerable в качестве результата своего выполнения. Для фильтрации данных мы воспользуемся методом Where в который передадим предикат записанный следующим образом n=>n.StartsWith(‘E’). С особенностями такого вида записи мы познакомимся в следующих лекциях пока же коротко объясним что выражение справа от => выполняется для каждого n (объявлен слева от =>) при этом n равняется очередному элементу коллекции.

Как можно заметить такая форма записи оказалось лаконичнее предыдущей при этом оба способа привели к одному и тому же результату - отфильтрованному выражению. При работе с коллекциями удобнее использовать цепочку методов LINQ и далее в этой лекции мы расскажем о возможностях LINQ на примере именно этого способа

**Важный момент, выражение LINQ выполняется не в момент когда мы его объявляем,а в момент когда происходит обращение к итератору. Если после построения выражение данные в источнике изменятся, выражение обработает уже измененный набор.**

```C#
string[] names = { "Анна", "Алена", "Анастасия", "Александр", "Алексей", "Елена", "Федор", "Михаил", "Елисей"};

IEnumerable<string> namesE = names.Where(n => n.StartsWith('Е'));

foreach (var n in namesE)
{
    Console.Write($"{n},"); // Елена,Елисей,
}

Console.WriteLine();

names[0] = "Екатерина";

foreach (var n in namesE)
{
    Console.Write($"{n},"); // Екатерина,Елена,Елисей,
}
```

Пример на скриншоте показывает итерацию одного и того же IEnumerable<string> полученного в результате построения LINQ выражения на 14 строке. Между первой (строки 16-19) и второй итерацией нашего выражения(строки 25-28) мы модифицируем массив источник записывая в его нулевую позицию имя начинающееся на ‘E’. Как видите во второй раз итератор “подхватил” все изменения сделанные в массиве.

Результатом работы LINQ является IEnumerable<T>или IQueryable<T> но не всегда T является тем же типом из которого состоят данные в источнике. Давайте разберем следующий пример: пусть у нас есть массив целых чисел и нам нужно выбрать из него только четные числа и вернуть набор объектов где каждый из объектов будет хранить исходное число и его квадрат.

```C#
int[] ints = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

var power1 = from i in ints
             where i % 2 == 0
             select
             new { Value = i, Power = i * i };

foreach (var p in power1)
{
    Console.WriteLine($" Power of {p.Value}={p.Power}");
    /*
     Power of 2=4
     Power of 4=16
     Power of 6=36
     Power of 8=64
     Power of 10=100
    */
}

Console.WriteLine();

var power2 = ints.Where(i => i % 2 == 0).Select(i => new { Value = i,Power = i * i });

foreach (var p in power1)
{
    Console.WriteLine($" Power of {p.Value}={p.Power}");
    /*
     Power of 2=4
     Power of 4=16
     Power of 6=36
     Power of 8=64
     Power of 10=100
    */
}
```

Источником данных как и в предыдущих примерах выступает массив определенный в строке 8. В 10-13 строках мы создаем LINQ выражение в котором:
1. в блоке в from мы указываем что источником данных является наш массив - ints а отдельным его членом будет переменная i
2. в блоке where мы фильтруем только те числа для которых i%2 будет равен 0 - как мы уже знаем этим способом можно определить четность числа
3. Блок select отличается от того что мы видели до этого, вместо того чтобы написать select i (тогда бы мы просто получили список четных чисел) мы конструируем экземпляр анонимного типа путем вызова оператора new и задания его полей в фигурных скобках. В данном случае анонимный класс имеет два поля Value - равняется самому числу, а Power - его степени 2 (для вычисления этого поля мы умножаем i само на себя, возводя его в квадрат)

Поскольку мы у нашего анонимного типа нет имени, мы не можем явно указать его в левой части операции присваивания и поэтому вместо IEnumerable<T> мы пишем просто var, оставляя вывод типа компилятору. В строках 15-17 мы перебираем все элементы нашего итератора, выводя на экран значения и степени. Еще раз обратите внимание на то что поскольку анонимный тип не имеет имени, везде где мы к нему обращаемся мы используем var.

В строке 22 мы конструируем выражение аналогичное предыдущему на этот раз используя цепочку LINQ методов. Уже знакомый нам Where получает предикат i=>i%2==0, проверяющий четность числа i. Следом за Where следует Select в котором мы создаем объект анонимного класса используя нашу переменную i. В строках 24-27 мы выводим на экран результат работы нашего выражения перебирая итератор в цикле foreach.

**Когда оператор Select создает что-либо отличное от копии исходного элемента такая операция называется проекцией**

Давайте посмотрим какие методы расширения существуют в LINQ:
- Select - уже знакомый нам метод для создания проекций данных (см предыдущий пример), результатом работы метода является энумератор
- Where - фильтрует данные с помощью предиката, результатом работы метода является энумератор
- OrderBy - упорядочивает результаты в порядке их возрастания

```C#
int[] ints = { 4, 5, 2, 1, 3};

IEnumerable<int> e = ints.OrderBy(i => i);

foreach (var n in e)
{
    System.Console.Write($"{n},"); // 1,2,3,4,5,
            }
```

- OrderByDescending - упорядочивает элементы по убыванию

```C#
int[] ints = { 4, 5, 2, 1, 3};

IEnumerable<int> e = ints.OrderByDescending(i => i);

foreach (var n in e)
{
    System.Console.Write($"{n},"); // 5,4,3,2,1,
}
```

- ThenBy - задает дополнительное условие сортировки
- ThenByDescending - задает дополнительное условие сортировки,но уже по убыванию

```C#
string[] fruits = {"яблоко","груша","апельсин","ежевика","черника","мандарин"};

IEnumerable<string> e = fruits.OrderBy(x => x.Length).ThenBy(x=>x);

foreach (var n in e)
{
    System.Console.WriteLine($"{n},");
    /*
    груша,
    яблоко,
    ежевика,
    черника,
    апельсин,
    мандарин,
    */
}
```

На скриншоте пример работы метода ThenBy для массива строк (в нем мы храним название фруктов) - обратите внимание на то что мы отсортировали фрукты по количеству букв в названии OrderBy(x=>x.Length) а потом отсортировали по алфавиту ThenBy(x=>x) (строка 10). Получилось так что в каждой группе фруктов одинаковой длины все фрукты отсортированы по алфавиту и сам фрукту при это отсортированы по количеству букв в названии.

- Join - объединяет коллекции по определенному признаку. Этот метод мы разберем позднее в следующих лекциях посвященных работе с базами данных
- Aggregate - применяет агрегатную функцию к элементам сводя все значения коллекции к одному объекту

```C#
int[] ints = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

int mult = ints.Aggregate((m, i) => m * i);

System.Console.WriteLine("Результат перемножения всех элементов коллекции = " + mult);
// Результат перемножения всех элементов коллекции = 3628800
```

На скриншоте в 10 строке пример работы метода Aggregate в которой мы передаем выражение в котором первый параметр это аккумулятор а второй является текущим элементов в коллекции. В данном примере, с помощью метода Aggregate мы перемножаем все элементы коллекции. Еще один пример работы функции Aggregate, в нем мы найдем максимальный элемент нашей коллекции (см ниже)

```C#
int[] ints = { 1, 2, 3, 4, 55, 6, 7, 8, 9, 10 };

int mult = ints.Aggregate((m, i) => m = i>m? i : m);

System.Console.WriteLine("Максимальное значение элементов = " + mult);
// Максимальное значение элементов = 55
```

На скриншоте в 10 строке мы реализовали поиск максимального элемента. Как происходит поиск - мы присваиваем m, переменной-аккумулятору текущее значение коллекции при условии что оно больше чем уже имеющееся в m.
- GroupBy - группировка элементов по ключу аналогичная той что происходит при работе с базами данных при применение условия группировки. Мы разберем оператор позже в лекции про БД
- GroupJoin - выполняет соединение коллекций и группировку по ключу. Как и предыдущий, метод проще объяснять на примере с базой данных потому отложим его разбор для лекции про БД
- ToLookup() - группирует элементы по ключу, формирую словарь с ключами заданными критерием выборки и значением выбранными критерием отбора

```C#
class Person
{
    public int Age { get; set; }
    public string Name { get; set; }

    public Person(int age, string name) 
    { 
        Age = age;
        Name = name;
    }
}
static void Main(string[] args)
{
    Person[] people =
    {
        new Person(20, "Тимофей"),
        new Person(23, "Семен"),
        new Person(21, "Павел"),
        new Person(23, "Иван"),
        new Person(23, "Константин"),
        new Person(21, "Борис"),
    };

    ILookup<int, Person> lookup = people.ToLookup(x => x.Age, y => y);

    foreach (IGrouping<int, Person?> l in lookup)
    {
        Console.Write($"Возраст {l.Key} = ");
        foreach (var p in l)
        {
            Console.Write(p.Name + ',');
        }
        Console.WriteLine();
    }
    /*
        Возраст 20 = Тимофей,
        Возраст 23 = Семен,Иван,Константин,
        Возраст 21 = Павел,Борис,
    */
}
```

Мы создали класс Person(строка 6-10) c двумя полями - Age - возраст и Name - имя, после чего создали массив значений этого класса (14-21 строки). Задача разбить людей на возрастные группы. Метод выполняющий задачу ToLookup вызывается в 23 строке. Он принимает два значения - первое это функцию определяющая элемент отбора x=>x.Age, и второе это какие элементы будут формировать наш словарь y=>y - в данном случае это класс Person. Метод возвращает объект поддерживающий интерфейс ILookup являющийся коллекцией элементов IGrouping<TKey, TValue> каждый элемент которой является коллекцией элементов TValue отобранных по критерию хранящемуся в свойстве Key элемента коллекции.

- Reverse - инвертирует порядок следования элементов

```C#
int[] ints = { 1, 2, 3, 4, 5 };

IEnumerable<int> reversed = ints.Reverse();

foreach (int i in reversed)
    Console.Write(i + " ");
// 5 4 3 2 1
```

- All - метод возвращает true если все элементы коллекции отвечают заданному условию.

```C#
int[] ints = { 1, 2, 3, 4, 5 };

bool AreGreaterThen0 = ints.All(x => x > 0);
bool areLowerThan0 = ints.All(x => x < 0);

Console.WriteLine("Все элементы больше 0=" + areGreatThan0);
Console.WriteLine("Все элементы больше 0=" + areLowerThan0);
// Все элементы больше 0=True
// Все элементы больше 0=False
```

Any - проверяет есть ли в коллекции хотя бы один элемент подходящий под условие.

```C#
int[] ints = { 0, 1, 2, 3, 4, 5 };

bool hasZero = ints.Any(x => x == 0);
bool hasNegative = ints.All(x => x < 0);

Console.WriteLine("В коллекции есть ноль?" + hasZero);
Console.WriteLine("В коллекции есть элемент меньше нуля?" + hasNegative);
// В коллекции есть ноль?True
// В коллекции есть элемент меньше нуля?False
```

- Contains - определяет наличие элемента в коллекции. Метод аналогичен таковому в коллекциях таких как например List
- Distinct - удаляет дублирующие элементы из коллекции

```C#
int[] ints = { 0, 1, 2, 2, 3, 4, 4, 5 };

IEnumerable<int> distict = ints.Distinct();

foreach (var i in distict)
    Console.Write(i + " ");
    // 0 1 2 3 4 5
```

- Except - удаляет из результирующей последовательности элементы не
входящие в переданную в метод последовательность.

```C#
int[] ints = { 0, 1, 2, 2, 3, 4, 4, 5 };

IEnumerable<int> except = ints.Distinct( 2, 4 );

foreach (var i in except)
    Console.Write(i + " ");
    // 0 1 3 5
```

- Union - соединяет две коллекции исключая дубликаты

```C#
int[] ints = { 0, 1, 2, 2, 3, 4, 4, 5 };

IEnumerable<int> union = ints.Union(new int[] { 2, 4, 6, 7 });

foreach (var i in union)
    Console.Write(i + " ");
    // 0 1 3 4 5 6 7
```

- Intersect - возвращает элементы которые есть в обеих коллекциях
(пересечение)

```C#
int[] ints = { 0, 1, 2, 2, 3, 4, 4, 5 };

IEnumerable<int> intersect = ints.Intersect(new int[] { 2, 4, 6, 7 });

foreach (var i in intersect)
    Console.Write(i + " ");
    // 2 4
```

- Count - подсчитывает количество элементов коллекции подходящее под условие-предикат

```C#
int[] ints = { 0, 1, 2, 2, 3, 4, 4, 5 };

int count1 = ints.Count();
int count2 = ints.Count(x => x % 2 == 0);

Console.WriteLine($"Количество элементов в коллекции = {count1}");
Console.WriteLine($"Количество четных элементов в коллекции = {count2}");
// Количество элементов в коллекции = 8
// Количество элементов в коллекции = 5
```

- Sum - подсчитывает сумму элементов коллекции

```C#
int[] ints = { 0, 1, 2, 2, 3, 4, 4, 5 };

int count1 = ints.Sum();

Console.WriteLine($"Сумма элементов в коллекции = {count1}");
// Сумма элементов в коллекции = 21

```

- Average - подсчитывает среднее арифметическое значение элементов в коллекции

```C#
int[] ints = { 0, 1, 2, 2, 3, 4, 4, 5 };

int count1 = ints.Average();

Console.WriteLine($"Среднее арифметическое элементов в коллекции = {count1}");
// Среднее арифметическое элементов в коллекции = 2.625
```

- Min - находит минимальный элемент в коллекции
- Max - находит максимальный элемент в коллекции

```C#
int[] ints = { 0, 1, 2, 2, 3, 4, 4, 5 };

int min = ints.Min();
int max = ints.Max();

Console.WriteLine($"Минимум в коллекции = {min}");
Console.WriteLine($"Максимум в коллекции = {max}");
// Минимум в коллекции = 0
// Максимум в коллекции = 5
```

- Take - выбирает заданное число элементов из коллекции

```C#
int[] ints = { 0, 1, 2, 2, 3, 4, 4, 5 };

IEnumerable<int> take = ints.Take(5);

foreach (var i in take)
    Console.Write(i + " ");
    // 0 1 2 2 3
```

- Skip - метод позволяет пропустить заданное количество элементов в коллекции

```C#
int[] ints = { 0, 1, 2, 2, 3, 4, 4, 5 };

IEnumerable<int> skip = ints.Skip(5);

foreach (var i in skip)
    Console.Write(i + " ");
    // 4 4 5
```

- TakeWhile - метод позволяет отобрать первые элементы из коллекции до тех пор пока они удовлетворяют заданному требованию (предикат)

```C#
int[] ints = { 0, 1, 2, 2, 3, 4, 4, 5 };

IEnumerable<int> takeWhile = ints.TakeWhile(x => x < 4);

foreach (var i in takeWhile)
    Console.Write(i + " ");
    // 0 1 2 2 3
```

Иллюстрация работы метода TakeWhile(строка 10). Обратите внимание метод прекращает свою работу как только встречает элемент не удовлетворяющий условию отбора.

- SkipWhile - метод позволяет пропустить N первых элементов коллекции не удовлетворяющих заданному условию. С помощью SkipWhile и TakeWhile удобно получать диапазоны данных удовлетворяющих условию.

```C#
int[] ints = { 0, 1, 2, 2, 3, 4, 4, 5 };

IEnumerable<int> skipWhile = ints.SkipWhile(x => x < 4).TakeWhile(x => x < 5);

foreach (var i in skipWhile)
    Console.Write(i + " ");
    // 4 4
```

- Concat - объединяет коллекции

```C#
int[] ints1 = { 0, 1, 2 };
int[] ints2 = { 3, 4, 5 };

IEnumerable<int> concat = ints1.Concat(ints2);

foreach (var i in skip)
    Console.Write(i + " ");
    // 0 1 2 3 4 5
```

- Zip - объединяет две коллекции в одну. Каждый элемент новой коллекции является операцией над элементами двух коллекций. Операция работает до тех пор пока можно выбирать по элементу из обеих коллекций.

```C#
int[] ints = { 0, 1, 2 };
char[] chars = { 'A', 'B', 'C', 'D'};

IEnumerable<int> res = ints.Zip(chars, (i, c) => "" + i + c);

foreach (var i in res)
    Console.Write(i + " ");
    // 0A 1B 2C
```

Пример показывает объединение двух коллекций(строка 11) где каждый элемент результирующей коллекции равняется строке сложенной из элементов первой и второй коллекции. Метод останавливается в в тот момент когда перестают поступать элементы в одной из коллекций. Таким образом количество элементов в результате равно количеству элементов в самой короткой из коллекций. Остаток игнорируется.

- First - выбирает первый элемент из коллекции соответствующий заданному условию. Если элемент не найден операция приведет к ошибке.

```C#
int[] ints = { 0, 1, 2, 3 };

int first = ints.First();
int firstNonZero = ints.First(x => x != 0);

Console.WriteLine($"Первый элемент коллекции = {first}");
Console.WriteLine($"Первый элемент коллекции не равный нулю = {firstNonZero}");
// Первый элемент коллекции = 0
// Первый элемент коллекции не равный нулю = 1
```

- FirstOrDefault - метод аналогичен методу First но в отличие от предыдущего не приводит к ошибке если значение не найдено. Вместо этого метод позволяет вернуть значение по умолчанию.


```C#
int[] ints = { 0, 1, 2, 3 };

int first = ints.FirstOrDefault(x=>x>10,-1);

Console.WriteLine($"Первый элемент в коллекции = {first}");
// Первый элемент в коллекции = -1
```

- Single - выбирает единственный элемент в коллекции удовлетворяющий заданному условию. Если элемент не найден или элементов подходящих под условие более одного то возникает ошибка.


```C#
int[] ints = { 0, 1, 3 };

int single = ints.Single(x => x>0 && x<3);

Console.WriteLine($"Единственный элемент в коллекции удовлетворяющий условию x>0 && x<3 = {single}");
// Единственный элемент в коллекции удовлетворяющий условию x>0 && x<3 = 1
```

- SingleOrDefault - по аналогии с методом FirstOrDefault метод позволяет задать значение по умолчанию в случае если элемент подходящий под условие не найден в коллекции


```C#
int[] ints = { 0, 1, 3 };

int single = ints.SingleOrDefault(x => x<0, -1);

Console.WriteLine($"Единственный элемент в коллекции удовлетворяющий условию x>0 && x<3 = {single}");
// Единственный элемент в коллекции удовлетворяющий условию x<0, -1 = -1
```

- ElementAt - получает элемент по заданному индексу коллекци, если индекс выходит за границы диапазона возникает ошибка.
- ElementAtOrDefault - выполняет ту же функцию что и предыдущий метод но как вы уже наверное догадались позволяет вернуть значение по умолчанию если индекс выходит за границы диапазона. Значением по умолчанию является значение по умолчанию для типа данных элементов коллекции. Для reference типов это будет null тогда как для value типов это будет значением которое предусмотрено для конкретного типа (0, 0.0, 0.0m и тп)


```C#
int[] ints = { 0, 1, 3 };

int element = ints.ElementAt(2);

Console.WriteLine($"Третий элемент в коллекции = {element}");

element = ints.ElementAtOrDefault(3);
Console.WriteLine($"Четвертый элемент в коллекции = {element}");
// Третий элемент в коллекции = 3
// Четвертый элемент в коллекции = 0
```

- Last - возвращает последний элемент коллекций удовлетворяющий заданному условию. Если элемент не найден возникает ошибка.
- LastOrDefault - возвращает последний элемент коллекций удовлетворяющий заданному условию. Если элемент метод возвращает заданное значение по умолчанию.


```C#
int[] ints = { 0, 1, 3, -1 };

int last = ints.Last(x=> x>1);

Console.WriteLine(last);

last = ints.LastOrDefault(x => x > 4, 0);

Console.WriteLine(last);
// 3
// 0
```

[🔝 Наверх](#содержание)

### Особенности работы с LINQ

LINQ является гибким и мощным инструментом извлечения данных. Большую часть времени вы будете применять его для работы с коллекциями и базами данных. Важно помнить что LINQ запрос результатом которого является IEnumerable или IQueryable (бд) не выполняется в момент построения выражение. Запрос будет выполнен лишь тогда когда мы начнем использовать данные например с помощью цикла foreach. Если источник данных был изменен перед выполнение запроса то запрос будет выполнен для измененных данных.

Методы LINQ не возвращаюшие IEnumerable например Count или FirstOrDefault отдают результат сразу по своему завершению.

Чтобы запрос и гарантированно сохранить данные в текущем состоянии для последующей работы можно преобразовать их в список или массив сразу после получения IEnumerable.

Следующий пример иллюстрирует поведение LINQ с изменение данных перед выполнением уже полученного запроса

```C#
int[] ints = { 0, 1, 3, -1, 5, 8 };

IEnumerable<int> res = ints.Where(x => x <=0);

ints[0] = 1;
ints[3] = 1;

foreach (var i in res)
    Console.Write(i + " ");
```

Пример иллюстрирует изменение источника данных запроса (строки 12 и 13) после построения LINQ выражения. Запрос не вернул значений так как элементы массива удовлетворяющие условию запроса были изменены.

Если нам важно получить текущий результат не беспокоясь о том, что источник может быть изменен стоит преобразовать наш LINQ запрос например в список и тогда запрос выполнится. При этом результат все также будет поддерживать IEnumerable


```C#
int[] ints = { 0, 1, 3, -1, 5, 8 };

IEnumerable<int> res = ints.Where(x => x <=0).ToList();

ints[0] = 1;
ints[3] = 1;

foreach (var i in res)
    Console.Write(i + " ");
// 0 -1
```


[🔝 Наверх](#содержание)