### ООП - Объектно ориентированное программирование(**Object oriented programming)**

ООП строится на 3-х основных принципах:
● Инкапсуляция – способность объекта скрывать свою внутреннюю
реализацию, объединяя в себя данные и методы; ИЛИ

Инкапсуляция - механизм языка, позволяющий объединить данные и методы, работающие с этими данными в единый объект, и скрыть детали реализации от пользователя.
● Наследование – возможность создавать новые объекты (наследник/child) на
основе уже существующих (родитель/parent). Объекты-потомки наследуют
поведение и свойства объектов родителей;
● Полиморфизм – способность выполнять действия с объектом вне
зависимости от его типа.

Абстрактный класс родитель Shape:

- метод CalculateArea
- метод SetColor

Классы наследники Square, Circle:

- метод CalculateArea унаследованный от родителя и у каждого реализован по своему, и не обязательно знать особенности их реализации, метод вернёт нам площадь этих объектов(Инкапсуляция)
- метод SetColor можно реализовать лишь единожды в классе Shape. “цвет” одинаков вне зависимости от типа фигуры. (Наследование)
- много уже созданных квадратов и кругов. Вам не важен тип фигуры, важно знать только ее площадь. **Полиморфизм** позволяет привести любой из этих объектов к классу Shape, и нам будет достаточно вызвать метод CalculateArea, не вдаваясь в подробности того, какой фигурой на самом деле является объект

### SOLID

- S – single responsibility – один объект одно предназначение.
- O – open close principle - класс может быть открыт к расширениям, но закрыт к модификациям.
- L – Liskov substitution principle – принцип подстановки
- I – interface segregation - разделение интерфейсов.
- D – dependency inversion - инверсия зависимости.

### DI

DI - dependency injection - Инжектор (-: 

### KISS

Keep it short and simple – код должен быть прост и понятен.

### DRY

Don’t repeat yourself

### YAGNI
You ain't gonna need it

### IoC

IoC - Inversion of control - Don’t call us, we’ll call you. Различные источники приводят различные паттерны, к которым может быть применен IoC. И скорее всего они все правы и просто дополняют друг друга. Вот некоторые их этих паттернов: factory, service locator, template method, observer, strategy.

### Процедура
Метод который ничего не возвращает, может называтся процедурой

### Параметры медода

Если в метод передано значение params, то именно оно становится значением параметра,
При его отсутсвии берется значение заданное в загаловке функции
***ВАЖНО!!!*** Параметры по умолчанию, должный идти последними в списке параметров метода.

### Ключевое слово params

### Свойства класса

Свойства(property) класса - это члены класса, реализующие доступ к полям класса.

или Accessor(Setter) и Mutator(Getter)

<pre><code>
[модификатор доступа] Тип ИмяСвойства
{
    [модификатор доступа] get;
    [модификатор доступа] set/init; 
    /* инит, по сути, создаёт константу в которую можно занести другое значение, при инициализации, кроме дефолтного. */
}
</pre></code>


### Required

required - ключевое слово используемое для обозначения обязательного для инициализации поля

Заметка удобно, с этим параметром, можно не делать конструктор, если есть обязательные для инициализации поля

<pre><code>
public class DataClass
{
    public required string Req;
}

DataClass dc1 = new DataClass() {Req = ""};
</pre></code>

в данном случае единственный способ создать экземпляр класса, это инлайн инициализация

***inline инициализация - в методах get, set/init***

### Наследование


### Приведение типов объектов

as

Оператор as работает следующим образом: он пытается преобразовать переменную
в тип, указанный после ключевого слово as, и если у него это получается, то
выражение возвращает приведенное значение. Если же приведение невозможно,
то выражение возвращает null.


is

Выражение возвращает true, если переменная принадлежит к классу с именем
ИмяКласса или к классу-родителю, и false, если нет.

<pre><code>
if (variable is SomeClassA outVariable)
    Console.WriteLine(outVariable);
</pre></code>

### Переопределение методов

В классе-родителе члены, которые могут быть переопределены в потомках, должны
быть помечены ключевым словом **virtual**

В классе-потомке можно переопределить члены класса-родителя с помощью
ключевого слова **override**.

<pre><code>
class ИмяКлассаРодителя
{
    virtual тип ИмяСвойства;
    virtual тип ИмяМетода()
    {
        код метода
    }
}
class ИмяКлассаПотомка:ИмяКлассаРодителя
{
    override тип ИмяСвойства;
    override тип ИмяМетода()
    {
        код метода
    }
}
</pre></code>


### Вызов методов базового типа
для этого используется ключевое слово base

### Модификаторы доступа

● public – к типу или члену, помеченному public, можно получить доступ из любого другого кода текущей или другой сборки.

● private – тип или член, помеченный словом private, доступен только коду текущего класса или структуры.

● protected – тип или член, помеченный словом protected, доступен только коду текущего класса или коду классов-наследников.

● internal – к типу или члену, помеченному internal, можно получить доступ из любого другого кода текущей, но не другой сборки.

● protected internal – к типу или члену, помеченному protected internal, можно получить доступ из любого другого кода текущей сборки или из классов
потомков, объявленных в других сборках.

● private internal – тип или член, помеченный словом protected, доступен только коду текущего класса или коду классов-наследников текущей сборки.

модификатор sealed запрещает наследовать

## Абстрактные классы и методы

Модификатор abstract может быть применен к классам, свойствам, методам, событиям и индикаторам.

При этом переменная может быть абстрактного типа, однако значение, лежащее в ней, должно обязательно принадлежать одному из
классов-потомков или же null.

### new методы

C# позволяет “спрятать” реализацию метода базового класса в классе наследнике.

Для того, чтобы спрятать метод родителя, нужно реализовать собственный с
идентичной сигнатурой.

### Запечатанные классы и методы

Иногда мы не хотим, чтобы наш класс имел потомков.

<pre><code>
[модификатор доступа] seales ИмяКласса
{
    [модификатор доступа] sealed тип имяМетода();
    [модификатор доступа] sealed тип имяСвойства{get;set;}
}

</pre></code>

### Статические методы

Статические методы не принадлежат экземплярам класса, и не имеют доступа к членам его экземпляров. Статические методы удобно использовать для реализации определенного функционала, который не связан с конкретным экземпляром класса.

### Статические классы

Статический класс – это специальный тип класса, работать с которым можно без
создания его экземпляра. Нельзя создавать экземпляры статического класса.
Статические классы нельзя наследовать. Нельзя объявлять унаследованные классы
статическими. Доступ к членам статического класса происходит через обращение к
его типу. Все члены статического класса должны быть помечены модификатором
static.

хороший пример, класс консоль

<pre><code>
[модификатор доступа] static ИмяКласса
{
    [модификатор доступа] static тип имяПеременной;
    [модификатор доступа] static тип имяМетода();
    [модификатор доступа] static тип имяСвойства{get;set;}
}
</pre></code>

Статические классы нельзя передавать в качестве параметров.

**Статический класс может иметь private-конструктор, который будет выполняться
автоматически** до первого обращения к любому члену этого класса.

<pre><code>
public static class Test
{
    static Test()
    {
        Console.WriteLine("Test constructor called");
    }
    public static void Print()
    {
        Console.WriteLine("Print method called");
    }
}

class Program
{
    static void Main()
    {
        Console.WriteLine("Console.WriteLine");

        Test.Print();
    }
}
</pre></code>

выведет 

<pre><code>
Console.WriteLine
Test constructor called
Print method called
</pre></code>

### Методы расширения

Это специальные методы, реализуемые вне класса, но имеющую семантику вызова,
идентичную методам класса, для которого они реализованы.

[модификатор доступа] static тип имяМетода(this тип имяПараметра);

<pre><code>
using System;
namespace Lection3Program2
{
    public static class StringUtils
    {
        public static string Reverse(this string s)
        {
            return new String(s.ToCharArray().Reverse().ToArray());
        }
    }

    static void Main()
    {
        string s = "Hello, World!";

        s = s.Reverse();

        Console.WriteLine(s);
    }
}
</pre></code>

<pre><code>
!dlroW ,olleH
</pre></code>

Обратите внимание, как мы вызываем метод Reverse (строка 8). Теперь вызов
выглядит так, как будто это обычный метод класса string.


### Partial классы

Реализацию класса можно разбить на несколько частей. Обычно это имеет смысл,
когда код дополняется каким-либо инструментом автогенерации кода. Например, в
фреймворке WPF C# генерирует часть кода графических форм приложений
(отрисовку графических элементов) самостоятельно в отдельном partial классе в
отдельном файле в процессе компиляции приложения, а разработчик реализует
свою часть кода в своей части partial класса в отдельном файле.

<pre><code>
using System;
namespace Practice1;

partial class Program
{
    static void Main()
    {
        TestPartial();
    }
}

partial class Program
{
    static void TestPartial()
    {
        Console.WriteLine("The method belong to the partial class");
    }
}
</pre></code>

Помимо partial-классов возможны также и partial-методы. Принцип их работы схож:
объявление и реализация могут находиться отдельно друг от друга.


## Интерфейсы

Интерфейсы в чем-то похожи на абстрактные классы, но, в отличие от последних, не могут
содержать реализацию и хранить состояние

поддерживают (могут содержать) методы, свойства, индексаторы и события.

Важно понимать, когда нужно использовать абстрактный класс, а когда интерфейс:
если требуется использовать одинаковым образом группу объектов, не связанных
наследованием, то интерфейс будет единственным решением. 

C# содержит предопределенные интерфейсы, реализовав которые можно наделить
ваш класс поддержкой различных алгоритмов платформы.

Пример таких интерфейсов это: ICloneable, IConvertible, IDisposable, IConvertible,
IComparable.

<pre><code>
public interface IComparable
{
    int CompareTo (object? obj);
}

public CompareTo(object? obj)
{
    if (obj == null)
        return -1;
    return this.Birthday.CompareTo((obj as Person).Birthday);
}
</pre></code>

Интерфейс не нужно описывать, так как он уже описан и является частью
библиотеки System.

Чтобы сортировка работала правильно, метод CompareTo должен
работать следующим образом: возвращать -1, если текущий объект
меньше переданного, 0, если объекты равны, и 1, если текущий объект
больше переданного в метод.


**Я всё равно описал.**

<pre><code>
internal class ComparablePerson : IComparable
{
    public ComparablePerson(int age, double height, double weight)
    {
        this.age = age;
        this.height = height;
        this.weight = weight;
    }

    public int age;
    public double height;
    public double weight;

    public int CompareTo(object? obj)
    {
        ComparablePerson p = obj as ComparablePerson;

        if (p != null)
        {
            if (age > p.age)
            {
                return -1;
            }
            else if (age < p.age)
            {
                return 1;
            }
            else
            {
                return 0;
            }
        }
        else
        {
            throw new Exception("Параметр должен быть типа ComparablePerson");
        }
    }
}
</pre></code>

**И вот метод для вставки в Main**
<pre><code>
public static void ComparablePerson()
{
    ComparablePerson[] persons = new ComparablePerson[10];

    Random r = new Random();

    for (int i = 0; i < persons.Length; i++)
    {
        persons[i] = new ComparablePerson(r.Next(1, 95), r.Next(30, 190), r.Next(20, 95));

        Console.WriteLine($"age: {persons[i].age} height: {persons[i].height} weight: {persons[i].age}");
    }

    Array.Sort(persons);

    Console.WriteLine(new string('-', 30));

    for (int i = 0; i < persons.Length; i++)
    {
        Console.WriteLine($"age: {persons[i].age} height: {persons[i].height} weight: {persons[i].age}");
    }

    Console.ReadKey();
}
</pre></code>

### Индексаторы

C# позволяет добавлять индексаторы в классы, что дает возможность обращаться к
ним тем же способом, что и к элементам массива, то есть с использованием индекса
– квадратных скобок.

<pre><code>
[модификатор доступа] тип this[type index]
{
    get{}//код получения значения по индексу
    set{}//код установки значения по индексу
}

public intarface IFamily
{
    Person this[int index]
    {
        get;
    }
    int Count { get;}
}
</pre></code>

реализация интерфеса в классе Person

<pre><code>
private Person[] Family;
public int Count {get {return 1 + (Family?.Length ?? 0);}}

public Person this[int index]
{
    get{
        if (index <=b) return this;
        if (Family is null)
            return null;
        if (Family.Length >= index)
            return Family[index-1]
        return null;
    }
}
</pre></code>

Обратите внимание на использование оператора “?”, идущего после Family и
оператора "null-объединения - ??” идущего после Length – с помощью “?” выражение Family?.Length
безопасно выполняется и возвращает null, если массив Family еще не
инициализирован. Если же он инициализирован, то возвращается длина массива. В
свою очередь, оператор “??” анализирует значение Family?.Length, и если оно равно
null, возвращает 0

??= забыли упомянуть о "операторе присваивания объединения со значением Null",
работает с 8 версии

### Переопределение операторов

-

### Реализация явного и неявного приведения

-

### Анонимные типы

-

### Записи (record)

-

## Обобщения (Generics)

-

### Generic наследование

-

### Generic методы

-

### Generic интерфейсы

-

### Generic интерфейсы, ковариантность, контравариантность и инвариантность

-

