### ООП - Объектно ориентированное программирование(**Object oriented programming)**

ООП строится на 3-х основных принципах:
● Инкапсуляция – способность объекта скрывать свою внутреннюю
реализацию, объединяя в себя данные и методы; ИЛИ

Инкапсуляция - механизм языка, позволяющий объединить данные и методы, работающие с этими данными в единый объект, и скрыть детали реализации от пользователя.
● Наследование – возможность создавать новые объекты (наследник/child) на
основе уже существующих (родитель/parent). Объекты-потомки наследуют
поведение и свойства объектов родителей;
● Полиморфизм – способность выполнять действия с объектом вне
зависимости от его типа.

Абстрактный класс родитель Shape:

- метод CalculateArea
- метод SetColor

Классы наследники Square, Circle:

- метод CalculateArea унаследованный от родителя и у каждого реализован по своему, и не обязательно знать особенности их реализации, метод вернёт нам площадь этих объектов(Инкапсуляция)
- метод SetColor можно реализовать лишь единожды в классе Shape. “цвет” одинаков вне зависимости от типа фигуры. (Наследование)
- много уже созданных квадратов и кругов. Вам не важен тип фигуры, важно знать только ее площадь. **Полиморфизм** позволяет привести любой из этих объектов к классу Shape, и нам будет достаточно вызвать метод CalculateArea, не вдаваясь в подробности того, какой фигурой на самом деле является объект

### SOLID

- S – single responsibility – один объект одно предназначение.
- O – open close principle - класс может быть открыт к расширениям, но закрыт к модификациям.
- L – Liskov substitution principle – принцип подстановки
- I – interface segregation - разделение интерфейсов.
- D – dependency inversion - инверсия зависимости.

### DI

DI - dependency injection - Инжектор (-: 

### KISS

Keep it short and simple – код должен быть прост и понятен.

### DRY

Don’t repeat yourself

### YAGNI
You ain't gonna need it

### IoC

IoC - Inversion of control - Don’t call us, we’ll call you. Различные источники приводят различные паттерны, к которым может быть применен IoC. И скорее всего они все правы и просто дополняют друг друга. Вот некоторые их этих паттернов: factory, service locator, template method, observer, strategy.

### Свойства класса
<pre><code>
[модификатор доступа] Тип ИмяСвойства
{
    [модификатор доступа] get;
    [модификатор доступа] set/init; 
    /* инит, по сути, создаёт константу в которую можно занести другое значение, при инициализации, кроме дефолтного. */
}
</pre></code>
### Ключевое слово params


### Required

required - ключевое слово используемое для обозначения обязательного для инициализации поля

Заметка удобно, с этим параметром, можно не делать конструктор, если есть обязательные для инициализации поля


***inline инициализация - в методах get, set/init***

### Модификаторы доступа

● public – к типу или члену, помеченному public, можно получить доступ из любого другого кода текущей или другой сборки.

● private – тип или член, помеченный словом private, доступен только коду текущего класса или структуры.

● protected – тип или член, помеченный словом protected, доступен только коду текущего класса или коду классов-наследников.

● internal – к типу или члену, помеченному internal, можно получить доступ из любого другого кода текущей, но не другой сборки.

● protected internal – к типу или члену, помеченному protected internal, можно получить доступ из любого другого кода текущей сборки или из классов
потомков, объявленных в других сборках.

● private internal – тип или член, помеченный словом protected, доступен только коду текущего класса или коду классов-наследников текущей сборки.

модификатор sealed запрещает наследовать

### Абстрактные классы и методы

Модификатор abstract может быть применен к классам, свойствам, методам, событиям и индикаторам.

При этом переменная может быть абстрактного типа, однако значение, лежащее в ней, должно обязательно принадлежать одному из
классов-потомков или же null.

### new методы

C# позволяет “спрятать” реализацию метода базового класса в классе наследнике.

Для того, чтобы спрятать метод родителя, нужно реализовать собственный с
идентичной сигнатурой.

### Запечатанные классы и методы

Иногда мы не хотим, чтобы наш класс имел потомков.

Для реализации подобного в C# есть модификатор **sealed**. Он может быть ***применен*** как к ***классу, методу или свойству***.

### Статические классы

Статический класс – это специальный тип класса, работать с которым можно без
создания его экземпляра. Нельзя создавать экземпляры статического класса.
Статические классы нельзя наследовать. Нельзя объявлять унаследованные классы
статическими. Доступ к членам статического класса происходит через обращение к
его типу. Все члены статического класса должны быть помечены модификатором
static.

Статические классы нельзя передавать в качестве параметров.

Статический класс может иметь private-конструктор, который будет выполняться
автоматически до первого обращения к любому члену этого класса.

<pre><code>
public static class Test
{
    static Test()
    {
        Console.WriteLine("Test constructor called");
    }
    public static void Print()
    {
        Console.WriteLine("Print method called");
    }
}

class Program
{
    static void Main()
    {
        Console.WriteLine("Console.WriteLine");

        Test.Print();
    }
}
</pre></code>

выведет 

<pre><code>
Console.WriteLine
Test constructor called
Print method called
</pre></code>

### Методы расширения

Это специальные методы, реализуемые вне класса, но имеющую семантику вызова,
идентичную методам класса, для которого они реализованы.

[модификатор доступа] static тип имяМетода(this тип имяПараметра);

<pre><code>
using System;
namespace Lection3Program2
{
    public static class StringUtils
    {
        public static string Reverse(this string s)
        {
            return new String(s.ToCharArray().Reverse().ToArray());
        }
    }

    static void Main()
    {
        string s = "Hello, World!";

        s = s.Reverse();

        Console.WriteLine(s);
    }
}
</pre></code>

<pre><code>
!dlroW ,olleH
</pre></code>

Обратите внимание, как мы вызываем метод Reverse (строка 8). Теперь вызов
выглядит так, как будто это обычный метод класса string.


### Partial классы

Реализацию класса можно разбить на несколько частей. Обычно это имеет смысл,
когда код дополняется каким-либо инструментом автогенерации кода. Например, в
фреймворке WPF C# генерирует часть кода графических форм приложений
(отрисовку графических элементов) самостоятельно в отдельном partial классе в
отдельном файле в процессе компиляции приложения, а разработчик реализует
свою часть кода в своей части partial класса в отдельном файле.

<pre><code>
using System;
namespace Practice1;

partial class Program
{
    static void Main()
    {
        TestPartial();
    }
}

partial class Program
{
    static void TestPartial()
    {
        Console.WriteLine("The method belong to the partial class");
    }
}
</pre></code>

Помимо partial-классов возможны также и partial-методы. Принцип их работы схож:
объявление и реализация могут находиться отдельно друг от друга.


### Интерфейсы

Интерфейсы в чем-то похожи на абстрактные классы, но, в отличие от последних, не могут
содержать реализацию и хранить состояние

поддерживают (могут содержать) методы, свойства, индексаторы и события.

Важно понимать, когда нужно использовать абстрактный класс, а когда интерфейс:
если требуется использовать одинаковым образом группу объектов, не связанных
наследованием, то интерфейс будет единственным решением. 

C# содержит предопределенные интерфейсы, реализовав которые можно наделить
ваш класс поддержкой различных алгоритмов платформы.

Пример таких интерфейсов это: ICloneable, IConvertible, IDisposable, IConvertible,
IComparable.

<pre><code>
public interface IComparable
{
    int CompareTo (object? obj);
}

public CompareTo(object? obj)
{
    if (obj == null)
        return -1;
    return this.Birthday.CompareTo((obj as Person).Birthday);
}
</pre></code>

Интерфейс не нужно описывать, так как он уже описан и является частью
библиотеки System.

Чтобы сортировка работала правильно, метод CompareTo должен
работать следующим образом: возвращать -1, если текущий объект
меньше переданного, 0, если объекты равны, и 1, если текущий объект
больше переданного в метод.


**Я всё равно описал.**

<pre><code>
internal class ComparablePerson : IComparable
{
    public ComparablePerson(int age, double height, double weight)
    {
        this.age = age;
        this.height = height;
        this.weight = weight;
    }

    public int age;
    public double height;
    public double weight;

    public int CompareTo(object? obj)
    {
        ComparablePerson p = obj as ComparablePerson;

        if (p != null)
        {
            if (age > p.age)
            {
                return -1;
            }
            else if (age < p.age)
            {
                return 1;
            }
            else
            {
                return 0;
            }
        }
        else
        {
            throw new Exception("Параметр должен быть типа ComparablePerson");
        }
    }
}
</pre></code>

**И вот метод для вставки в Main**
<pre><code>
public static void ComparablePerson()
{
    ComparablePerson[] persons = new ComparablePerson[10];

    Random r = new Random();

    for (int i = 0; i < persons.Length; i++)
    {
        persons[i] = new ComparablePerson(r.Next(1, 95), r.Next(30, 190), r.Next(20, 95));

        Console.WriteLine($"age: {persons[i].age} height: {persons[i].height} weight: {persons[i].age}");
    }

    Array.Sort(persons);

    Console.WriteLine(new string('-', 30));

    for (int i = 0; i < persons.Length; i++)
    {
        Console.WriteLine($"age: {persons[i].age} height: {persons[i].height} weight: {persons[i].age}");
    }

    Console.ReadKey();
}
</pre></code>

65 страница