# Разработка приложения на С# (лекции)

## Урок 2. Интерфейсы и обощения

### Интерфейсы

Интерфейсы в чем-то похожи на абстрактные классы, но, в отличие от последних, не могут
содержать реализацию и хранить состояние

поддерживают (могут содержать) методы, свойства, индексаторы и события.

Важно понимать, когда нужно использовать абстрактный класс, а когда интерфейс:
если требуется использовать одинаковым образом группу объектов, не связанных
наследованием, то интерфейс будет единственным решением. 

C# содержит предопределенные интерфейсы, реализовав которые можно наделить
ваш класс поддержкой различных алгоритмов платформы.

<pre><code>
[модификатор доступа] interface IИмяИнтерфейса
{
    //методы, свойства, события, индексаторы
}
[модификатор доступа] class ИмяИмяКласса:IИмяИнтерфейса
{
    //методы, свойства, события, индексаторы
}
</code></pre>

Пример таких интерфейсов это: ICloneable, IConvertible, IDisposable, IConvertible,
IComparable.

<pre><code>
public interface IComparable
{
    int CompareTo (object? obj);
}

public CompareTo(object? obj)
{
    if (obj == null)
        return -1;
    return this.Birthday.CompareTo((obj as Person).Birthday);
}
</code></pre>

Интерфейс не нужно описывать, так как он уже описан и является частью
библиотеки System.

Чтобы сортировка работала правильно, метод CompareTo должен
работать следующим образом: возвращать -1, если текущий объект
меньше переданного, 0, если объекты равны, и 1, если текущий объект
больше переданного в метод.


**Я всё равно описал.**

<pre><code>
internal class ComparablePerson : IComparable
{
    public ComparablePerson(int age, double height, double weight)
    {
        this.age = age;
        this.height = height;
        this.weight = weight;
    }

    public int age;
    public double height;
    public double weight;

    public int CompareTo(object? obj)
    {
        ComparablePerson p = obj as ComparablePerson;

        if (p != null)
        {
            if (age > p.age)
            {
                return -1;
            }
            else if (age < p.age)
            {
                return 1;
            }
            else
            {
                return 0;
            }
        }
        else
        {
            throw new Exception("Параметр должен быть типа ComparablePerson");
        }
    }
}
</code></pre>

**И вот метод для вставки в Main**
<pre><code>
public static void ComparablePerson()
{
    ComparablePerson[] persons = new ComparablePerson[10];

    Random r = new Random();

    for (int i = 0; i < persons.Length; i++)
    {
        persons[i] = new ComparablePerson(r.Next(1, 95), r.Next(30, 190), r.Next(20, 95));

        Console.WriteLine($"age: {persons[i].age} height: {persons[i].height} weight: {persons[i].age}");
    }

    Array.Sort(persons);

    Console.WriteLine(new string('-', 30));

    for (int i = 0; i < persons.Length; i++)
    {
        Console.WriteLine($"age: {persons[i].age} height: {persons[i].height} weight: {persons[i].age}");
    }

    Console.ReadKey();
}
</code></pre>

### Индексаторы

C# позволяет добавлять индексаторы в классы, что дает возможность обращаться к
ним тем же способом, что и к элементам массива, то есть с использованием индекса
– квадратных скобок.

<pre><code>
[модификатор доступа] тип this[type index]
{
    get{}//код получения значения по индексу
    set{}//код установки значения по индексу
}

public intarface IFamily
{
    Person this[int index]
    {
        get;
    }
    int Count { get;}
}
</code></pre>

реализация интерфеса в классе Person

<pre><code>
private Person[] Family;
public int Count {get {return 1 + (Family?.Length ?? 0);}}

public Person this[int index]
{
    get{
        if (index <=b) return this;
        if (Family is null)
            return null;
        if (Family.Length >= index)
            return Family[index-1]
        return null;
    }
}
</code></pre>

Обратите внимание на использование оператора “?”, идущего после Family и
оператора "null-объединения - ??” идущего после Length – с помощью “?” выражение Family?.Length
безопасно выполняется и возвращает null, если массив Family еще не
инициализирован. Если же он инициализирован, то возвращается длина массива. В
свою очередь, оператор “??” анализирует значение Family?.Length, и если оно равно
null, возвращает 0

??= забыли упомянуть о "операторе присваивания объединения со значением Null",
работает с 8 версии

### Индексаторы

C# позволяет добавлять индексаторы в классы, что дает возможность обращаться к ним тем же способом что и к элементам массива, то есть с использованием индекса – квадратных скобок.

<pre><code>
[модификатор доступа] тип this[type index]
{
    get{}//код получения значения по индексу
    set{}//код установки значения по индексу
}
</code></pre>

сделаем интерфейс IFamily, который будет добавлять классу, реализующему его, возможность работать с ним как с массивом значений

<pre><code>
namespace Lection2
{
    public interface IFamily
    {
        Person this[int index] { get; }
        int Count { get; }
    }
}
</code></pre>

пример интерфейса IFamily. С помощью индексатора мы будем обращаться к членам семьи, а свойство Count нам пригодится для определения количества ее членов

    private Person[] Family;
    public int Count { get { return 1 + (Family?.Length ?? 0); } }

    public Person this[int index] {
        get {
            if (index <= 0) return this;
            if (Family is null)
                return null;
            if (Family.Length >= index)
                return Family[index-1];
            return null;
        }
    }

### Переопределение операторов

Пользовательские классы могут перегружать предопределенные операторы языка таким образом, чтобы их можно было применять в сочетании с этими классами.


    public static operator оператор(операнд/операнды)
    {
        код возвращающий результат операции
    }

Переопределять можно следующие операторы:

+x,-x,!x,~x,++,--, true, false

x+y, x-y, x*y, x/y, x%y

x&y, x|y, x^y,

x==y, x!=y, x<y, x>y, x<=y, x>=y

Операторы true и false, == и !=, < и >, <= и >= могут быть переопределены только в
паре.

напишем класс Fibonacci, который будет подсчитывать числа Фибоначчи с помощью оператора унарного инкремента “++”, применяемого к экземпляру этого класса


### Реализация явного и неявного приведения

Для пользовательских классов можно определять операции явного и неявного приведения.

    public static implicit/explicit operator ИмяВозвращаемого типа(параметр)
        {
            return результат;
        }

Ключевое слово implicit следует использовать для реализации оператора неявного приведения типа, тогда как explicit для явного.

Важно помнить, что методы неявного преобразования стандартных типов C# никогда не приводят к возникновению исключительных ситуаций (ошибок), соответственно, при разработке своего неявного преобразования следует придерживаться такого же принципа. Если вы по какой-либо причине думаете, что ошибки преобразования все-таки возможны, то такое преобразование следует реализовать как явное.


### Анонимные типы

Анонимные типы являют собой простой способ собрать в одном месте значения для последующего использования

    var name = new {имя_свойства = значение,...}

### Записи (record)

Если классы предназначены для описания поведения и иерархии наследования, то записи или record предназначены для хранения данных. В общем виде объявление записей выглядит следующим образом:

    [модификатор доступа]record [class/struct] Имя(тип имя)
    {
        //поля
    }

Обратите внимание на круглые скобки, идущие за ключевым словом record – в них можно указать список свойств записи, доступных только для чтения. Это можно сравнить с конструктором класса, но, в отличие от записей, в объекте класса эти параметры остаются локальными и не становятся его частью, если, конечно, не присвоить их каким-либо заранее объявленным полям. Поля record, объявленные в заголовке record (в круглых скобках), являются иммутабельными – это значит, что значения, переданные через конструктор, нельзя будет изменить после создания экземпляра record. Поля, находящиеся в фигурных скобках, являются
мутабельными.

Тип record умеет быть как value, так и reference-типом. По умолчанию все записи являются ссылочными, если для них явно не указать модификатор struct при объявлении. Модификатор class является опциональным и может дополнительно указывать разработчику на то, что запись является reference-типом.

    record class ReferenceRecord(int a)
    {
        public int b = 0;
    }
    
    record class ValueRecord(int a)
    {
        public int b = 0;
    }

В коде ReferenceRecord являются reference-типом, тогда как ValueRecord – value-типом. Как мы помним из материала предыдущих лекций, value-типы при присваивании и передаче в функцию копируются, тогда как reference-типы передаются по ссылке.

    var record = new Record(10);

    var record1 = new ReferenceRecord(10);
    var record2 = record1;

    record2.b = 20;
    System.Console.WriteLine(record1.b); // 20


    var record3 = new ValueRecord(10);
    var record4 = record1;

    record4.b = 20;
    System.Console.WriteLine(record3.b); // 0

Как видно из кода, после присваивания значения record1 переменной record2 и последующего изменения поля record2.b, при выводе на печать поля record2.a выводится измененное значение. Тогда как схожий код, но уже оперирующий объектами типа record struct, приводит к копированию значения, и измененное значение record4.b никак не влияет на сканированный оригинал
record3.b (строки 21-25). Главное отличие записей от структур и классов заключается в том, что компилятор автоматически реализует для них интерфейс IEquatable, позволяющий сравнивать их с учетом значений, хранящихся в них.

    record Record(int a)
    {
        public int b { get; set; } = 0;
    }

    Static void Main(string[] args)
    {
        var record2 = new Record(10);
        var record1 = new Record(10);

        System.Console.WriteLine(record1 == record2); // True

        record1.b = 20;

        System.Console.WriteLine(record1 == record2); // False
    }


пока все значения полей первого экземпляра равны значениям полей второго экземпляра, операция сравнения будет возвращать true

    System.Console.WriteLine(record1); // Record { a = 10, b = 20 }

Вторым важным методом, автоматически реализуемым компилятором, является ToString(). В отличие от классов, где ToString, если его не переопределить, возвращает имя класса, в записях ToString() возвращает список полей и их значений.

Еще одним важным свойством записей является возможность их копирования (даже record class) с одновременным изменением их полей – копирование с недеструктивной мутацией. Для этого служит ключевое слово with, после которого уже знакомым нам синтаксисом inline инициализации можно задать значение полей, которые мы хотим изменить.

    record Record(int a)
    {
        public int b { get; set; } = 0;
    }

    Static void Main(string[] args)
    {
        var record1 = new Record(10);

        Record record2 = record1 with { b = 10 };
        Record record3 = record1 with { b = 15 };

        System.Console.WriteLine(record1); // Record { a = 10, b = 0 }
        System.Console.WriteLine(record2); // Record { a = 10, b = 10 }
        System.Console.WriteLine(record3); // Record { a = 15, b = 0 }
    }

Иллюстрация показывает пример копирования записей с мутацией отдельных полей.

## Обобщения (Generics)

Обобщения – это способ создать “универсальную” логику в классе или методе,
откладывая уточнение спецификации до момента вызова конструктора класса. Это
достигается путем применения обобщенных параметров.

    [модификатор доступа] class имя<T1,T2,..,Tn>
    {
        T1 Имя1; //переменная
        T1 Имя2 {get;set;} //свойство
        T2 Имя(Tn имя) //метод
        {
        }
    }

Где T1, T2, Tn – имена типов (их может быть произвольное количество). Обобщения активно используются C#, в следующей лекции у нас будет достаточно таких примеров (Коллекции). Мы уже встречались с обобщениями в таком типе данных, как кортежи.


### Generic наследование

-

### Generic методы

-

### Generic интерфейсы

-

### Generic интерфейсы, ковариантность, контравариантность и инвариантность

-
